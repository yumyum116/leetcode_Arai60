## Step 1
・解答の方針としては次の流れを想定。
①引数で与えられた nums1 から、要素の重複を削除した配列を set 関数を用いて作成する。
②①で作成した配列の長さを繰り返し回数として、新規作成した配列の要素と nums2 の要素を比較する。
③nums2 に含まれる要素のみ、戻り値を格納する配列 result に追加する。
④③の結果、生成された配列を戻り値として返す。
⇛ Accepted となったものの、時間計算量の観点では大幅に改善できることが伺える。値をインデックスベースで取得する目的でのリスト作成は改善の余地があるものと推測。

時間計算量：O(n * m)
空間計算量：O(n)

## Step 2
・今回の問題では、要素の位置に関する情報は重要ではないため、iterable の性質があれば十分。
・iterable である場合、foreach 機能としての for 文を使用することにより、繰り返し変数の範囲を定めるための変数を使用する必要がなくなる。
⇛メモリ消費量の観点で、やや改善できる。

## Step 3
・runtime が 0 ms のため、変更点はなし。可読性の観点においても、変更すべき箇所はないものと判断。強いて修正点を挙げるとするならば、変数名か。

## Step 4
> ここがリストの判定なので、要素数が20くらいから遅くなると思います。
⇛ メモリは消費するものの、初めに配列の Hash Map を作成し、作成した Hash Map を基に処理を行えば、要素数に左右されずに安定したパフォーマンスを生み出せるか。
以下のコメントを拝見し、in list ではなく、if continue を用いることも選択肢の一つとしてはあるかもしれないが、if continue を使う場合の条件文が浮かばない（結局 in list を使いそう）ため、Hash Map で処理することを検討する。

https://github.com/shining-ai/leetcode/pull/13


> 例えば、nums1 と nums2 の要素数に大きな偏りがある場合、どうしたら効率的にできるでしょうか。また、それぞれ要素数が巨大なもののソートされていているなら、どうしましょうか。
⇛配列の要素数を比較し、配列の要素数が少ない方の配列を条件判定に用いる。配列がソートされている場合には、要素数が少ない方の配列の末尾の値を、要素数が多い方の配列を走査し、
その結果得られるインデックスを for文の繰り返しの終了値とすることで、走査不要な範囲を走査することを防ぐことができる。
※ただし、「要素数の少ない配列の最大値＝要素数の多い配列の最大値」となる場合は、あまり効果がない。
