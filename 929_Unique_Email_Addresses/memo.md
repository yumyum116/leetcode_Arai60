## step1
想起したアプローチ（ロジック）：
・ローカル名とドメイン名で文字列を分割
・ローカル名の中に「.」が含まれているかどうかを判定し、含まれている場合には、「.」を削除したローカル名に更新する
・ローカル名の中に「+」が含まれているかどうかを判定し、含まれている場合には、「+」以降の文字列を削除したローカル名に更新する
・上記の処理を経た各要素について、ローカル名ごとの比較を行い、ローカル名が一致した場合にはドメイン名を比較する。ドメイン名も一致した場合には、カウンタを１加算する
⇛ローカル名を処理したものとドメイン名を連結し、重複を排除した配列を新たに作成し、配列の要素数を戻り値とすることで、カウンタ変数を使わない方法に変更

・アクセプトはされたものの、ローカル名、ドメイン名で それぞれ Hash Map を作らずに同じ結果を得る方法を考えたい。

・時間計算量：O(N * M)
・空間計算量：O(N * M)

## step2
参考にしたPR：
https://github.com/ksaito0629/leetcode_arai60/pull/13/changes
https://github.com/aki235/Arai60/pull/14/changes

■気がついたこと
MUST
・引数チェック入れる(※実務においては考慮が必要。ただし、問題を解く上では、emails の要素数が１以上であることが条件のため、引数が空であるかどうかのチェックは不要。)

Nice to Have
・RFC5322 のメールアドレスの規格で、'@' は２つ以上含まれる可能性がある（ローカル名にも'@'が含まれる可能性がある）ことを根拠に、
　'@' が１つではない場合の処理を条件分岐で記述されている方もいる。問題を解くという観点においては、問題の条件には「'@'は一つのみ含まれる」とされているため、
　'@' の数による条件分岐は考慮する必要はない。一方で、実務においては、メールアドレスの登録、メールの送信時等に利用されるケースが想定されるため、
　入力値のバリデーションチェックは必要であると思慮。
・正規表現を用いる解法もある

疑問
・なぜ len(domain_name) < 4 なら continue なのか？何を基にこの条件があるのか？


個人的に勉強する必要があること（メモ）
・「Pythonでは文字列はイミュータブルなので、追記には再構築が走る」とはどういうことなのか
・そもそも文字列がイミュータブルであるということはどういうことなのか。イミュータブルでないということはどういうことなのか
・再構築とは、どのレベルの再構築なのか。配列削除⇛メモリ確保⇛要素追加、の処理が、追記の度に実行されることを指しているのか
・RFC5322は何を規定した規格なのか。他に関連する規格もチェック ⇛RFC2822（IMF）の更新版
